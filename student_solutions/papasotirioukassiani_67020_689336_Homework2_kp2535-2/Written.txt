Problem 1//import Collection;import java.util.LinkedList;public class Problem1 {public static void main(String[] args){System.out.println("Excercise 1");	LinkedList<Integer> list_L = new LinkedList<Integer>();for (int i=1; i<=100;i+=1)	list_L.add(i);LinkedList<Integer> list_Positions = new LinkedList<Integer>();for (int i=0; i<=20;i+=4)	list_Positions.add(i);printLots(list_Positions,list_L);}private static void printLots(LinkedList<Integer> Positions, LinkedList<?> L){	System.out.println("The positions that will be desplayers are: "+Positions);	System.out.println("The objects in the list L are: "+L);	Object[] myArray = L.toArray();		Object[] positions = (Object[]) Positions.toArray();	for (int i=0; i<positions.length; i++)	{		System.out.println("data of the Linked list L in the position: "+(int) positions[i] +" is: "+myArray[(int) positions[i]]);	}}Problem 2import java.util.LinkedList;import java.util.ListIterator;public class Problem2 {public static void main(String[] args){	System.out.println("Excercise 2");		LinkedList<Integer> list_L = new LinkedList<Integer>();	for (int i=0; i<=100;i+=5)		list_L.add(i);	LinkedList<Integer> list_Positions = new LinkedList<Integer>();	for (int i=0; i<=100;i+=10)		list_Positions.add(i);	intersection(list_Positions,list_L);	}				private static void intersection(LinkedList<Integer> list_A, LinkedList<Integer> list_B){ListIterator<Integer> iter = list_A.listIterator();while(iter.hasNext()){	int current_integer=iter.next();	if(list_B.contains(current_integer))		System.out.println(current_integer);			}			}					}Problem 3public class Problem3 {private static final int stackSize=10; private static int[] stackArray;//= new int[stackSize];private static int stack_One_pointer=0;private static int stack_Two_pointer=stackSize-1;public static void main(String[] args){stackArray = new int[stackSize];stack_One_pop();stack_Two_pop();for (int i=0; i<=12;i++){	stack_One_push(i+100);	stack_Two_push(i+400);	System.out.print("Contents of the stack: ");	for (int j=0;j<stackSize;j++)		System.out.print(stackArray[j]+" ");	System.out.println();	if(i==8){		System.out.println( stack_One_pop());		stack_Two_push(i+400);		System.out.println( stack_One_pop());		stack_Two_push(i+400);		System.out.println( stack_One_pop());	}}}	public static void stack_One_push(int number){if(stack_One_pointer>stack_Two_pointer)	System.out.println("The stack space is full imposible to push further inetegers until the pop function be occured.");	else{	stackArray[stack_One_pointer]=number;	stack_One_pointer++;}}public static int stack_One_pop(){if(stack_One_pointer==0)	{System.out.println("nothing to pop up");	return -1;}else{	stack_One_pointer--;	return stackArray[stack_One_pointer];}		}public static void stack_Two_push(int number){if(stack_One_pointer>stack_Two_pointer)	System.out.println("The stack space is full imposible to push further inetegers until the pop function be occured.");	else{	stackArray[stack_Two_pointer]=number;	stack_Two_pointer--;}	}public static int stack_Two_pop(){	if(stack_Two_pointer==stackSize-1)	{System.out.println("nothing to pop up");	return -1;}	else{		stack_One_pointer++;		return stackArray[stack_One_pointer-1];}		}}Problem 4//Problem4/*a) * 1.Move 4 to s3 * 2.Move 3 to s2 * 3.Move 1 to the back of the output track * 4.Move 8 to s1 * 5.Move 2 to the back of the output track * 6.Move 3 to the back of the output track * 7.Move 4 to the back of the output track * 8.Move 7 to s1 * 9.Move 6 to s1 * 10.Move 5 to the back of the output track * 11.Move 6 to the back of the output track * 12.Move 7 to the back of the output track * 13.Move 8 to the back of the output track * 14.Move 9 to the back of the output track * b)198765432, in order to output this track in the right way it is necessary to have the greatest numbers at the bottom of the stack and continue adding elements in a descending order. In this specific example we have to put the smaller numbers of the * */