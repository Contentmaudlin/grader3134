COMS 3134 Homework 2
Madeline Wu (mcw2175)
October 7, 2016

PROBLEM 1:

public void printLots(List l<AnyType>, List<Integer> p) {
    Iterator<Integer> pIter = p.iterator();
    Iterator<AnyType> lIter = l.iterator();
    int index = 0;

    while (pIter.hasNext() && lIter.hasNext()) {
        if (p.next() == index) {
            System.out.println(l.next());
        } else {
            l.next();
        }
        index++;
    }
    if (pIter.hasNext()) {
    	System.out.println(“Couldn’t print elements at p.next() because that index 				     doesn’t exist in List l. ”);
    }
}

PROBLEM 2 (3.4):
Given two sorted lists, L1 and L2,
write a procedure to compute L1 ∩ L2 using only the basic list operations.
Union: add elements from both lists

 public List union(List L1, List L2) {
    List L3 = new LinkedList<>();
    if (L1 != null && L2 != null) {
    	for (Object x : L1) {
       		if (L2.contains(x)) {
            	L3.add(x);
        	}
    	}
    }
    return L3;
 }

PROBLEM 3 (3.24):

public class TwoStackArray<AnyType> {

    AnyType[] arr;
    int index1 = 0;
    int index2;

    public TwoStackArray(int x) {
        arr = (AnyType[]) new Object[x];
        index2 = arr.length - 1;
    }

    public void push1(AnyType item) {
        if (index1 != index2) {
            arr[index1] = item;
            index1++;
        } else {
            throw new StackOverflowError("Array is at full capacity.");
        }
    }

    public AnyType pop1() {
        index1--;
        return arr[index1 + 1];
    }

    public AnyType peek1() {
        return arr[index1];
    }

    public boolean empty1() {
        return (index1 == 0);
    }

    public void push2(AnyType item) {
        if (index1 != index2) {
            arr[index2] = item;
            index2--;
        } else {
            throw new StackOverflowError("Array is at full capacity.");
        }
    }

    public AnyType pop2() {
        index2++;
        return arr[index2 - 1];
    }

    public AnyType peek2() {
        return arr[index2];
    }

    public boolean empty2() {
        return ((arr.length - 1) == index2);
    }

} //end class

PROBLEM 4:

S1, S2, and S3 are the three holding tracks.

A) 1. Add 4, then 3 to S1.
   2. Add 1 to the back of the output track.
   3. Add 8 to S2.
   4. Add 2 to the back of the output track.
   5. Move 3, then 4 from S1 to the back of the output track.
      (Track, front to back, is now [1, 2, 3, 4].
      Only S2 is not empty and holds 8).
   6. Add 7, then 6, to S2.
   7. Add 9 to S3.
   8. Add 5 to the back of the output track.
      (Track, front to back, is now [1, 2, 3, 4, 5].
      S2 (top to bottom): 6, 7, 8
      S3: 9
   9. Add 6, then 7, then 8, from S2 to the back of the output track.
   10. Add 9 from S3 to the back of the output track.
       (Track, front to back, is now [1, 2, 3, 4, 5, 6, 7, 8, 9]).

B)
Read from left to right as back to front of the input track (like the example used in part A):
[5, 6, 2, 1, 9, 8, 7, 3, 4].

1 had to be added to the output queue first, so all numbers that are in front of 1
must be added to holding tracks so that the bottom of each holding track is the largest
number on that track (because only the top can be accessed, so you want the smallest number
on top).
These are the tracks (left is top, right is bottom) after adding all numbers preceding 1:
S1: 3, 4
S2: 9, 7
S3: 8
After 1 and 2 are added to the output track, 3 and 4 can be added from S1.
6 can be added to the top of any track, and 5 can then be added from the input track
to the output track. After that, 6 can be added as well.
7 cannot be added because it's beneath 9, which makes an increasing order rearrangement
impossible for this set of numbers. This is because you can't switch trains between holding tracks.
If 9 had been added to S3 instead of S2, a similar problem would have happened
when trying to add 8 to the output track.




