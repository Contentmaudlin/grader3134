Name: Anlan Huang  UNI: ah3358

1.
public static <AnyType> void printLots(List<AnyType> L, List<Integer> P) {
     java.util.Iterator<AnyType> itr1 = L.iterator();

     Integer i = 0;

     // Print the elements in L that are in positions specified by P
     while (itr1.hasNext()) {
         if (P.contains(i)) {
             System.out.println(itr1.next());
         } else {
             itr1.next();
         }
         i++;
     }
 }

2.
public static <AnyType> List<AnyType> listIntersection(List<AnyType> L1,
                                             List<AnyType> L2) {
    // Pseudo-code for creating a list
    List<AnyType> L = List<AnyType>();

    // Iterate L1 to check whether there exists the same value in L2
    Iterator<AnyType> itr1 = L1.iterator();
    Iterator<AnyType> itr2 = L2.iterator();
    AnyType element1 = itr1.next();
    AnyType element2 = itr2.next();

    while (itr1.hasNext() && itr2.hasNext()) {
        //Pseudo-code for comparing elements in L1 and L2
        if (element1 < element2) {
            element1 = itr1.next();
        } else if (element1 > element2) {
            element2 = itr2.next();
        } else {
            L.add(element1);
            element1 = itr1.next();
            element2 = itr2.next();
        }
    }

    //Pseudo-code for checking if the last element in L1 is equal to the
    // last element in L2
    if (element1 == element2) {
        L.add(element1);
    }

    //Check if an element in L1 is equal to the last element in L2
    if (!itr2.hasNext()) {
        while (itr1.hasNext()) {
            element1 = itr1.next();
            if (element1 == element2) {
                L.add(element1);
            }
        }
        
    //Check if an element in L2 is equal to the last element in L1
    } else if (!itr1.hasNext()) {
        while (itr2.hasNext()) {
            element2 = itr2.next();
            if (element1 == element2) {
                L.add(element1);
            }
        }
    }
    return L;
}

3.
public class TwoStacks<AnyType> {
    final int CAPACITY = 100;
    AnyType[] arr = (AnyType[]) new Object[CAPACITY];
    private int stack1CurrentIndex = 0;
    private int stack2CurrentIndex = arr.length - 1;

    public void push(AnyType x, int stack) {
        // If the selected stack is not stack 1 or stack 2, report an error
        if (!(stack == 1 || stack == 2)) {
            Error();
        }

        // If every slot in the array is used, report an stack overflow error
        if (stack1CurrentIndex + 1 == stack2CurrentIndex) {
            //StackOverflowError();
        }

        // Push an element into stack1
        if (stack == 1) {
            arr[stack1CurrentIndex++] = x;
        }

        // Push an element into stack2
        if (stack == 2) {
            arr[stack2CurrentIndex--] = x;
        }
    }

    public AnyType top(int stack) {

        // If the selected stack is not stack 1 or stack 2, report an error
        if (!(stack == 1 || stack == 2)) {
            //Error();
        }

        if (stack == 1) {
            // If the stack index is out of bound, return null
            if (stack1CurrentIndex < 0) {
                return null;
            }
            // Peep an element from stack 1
            return arr[stack1CurrentIndex];
        }

        if (stack == 2) {
            // If the stack index is out of bound, return null
            if (stack2CurrentIndex >= arr.length) {
                return null;
            }
            // Peep an element from stack 2
            return arr[stack2CurrentIndex];
        }
    }

    public AnyType pop(int stack) {

        // If the selected stack is not stack 1 or stack 2, report an error
        if (!(stack == 1 || stack == 2)) {
            Error();
        }

        if (stack == 1) {
            // If the stack index is out of bound, return null
            if (stack1CurrentIndex < 0) {
                return null;
            }
            // Pop an element from stack 1
            return arr[stack1CurrentIndex--];
        }

        if (stack == 2) {
            // If the stack index is out of bound, return null
            if (stack2CurrentIndex >= arr.length) {
                return null;
            }
            // Pop an element from stack 2
            return arr[stack2CurrentIndex++];
        }
    }

    public boolean isEmpty(int stack) {
        // If the selected stack is not stack 1 or stack 2, report an error
        if (!(stack == 1 || stack == 2)) {
            Error();
        }

        if (stack == 1) {
            return stack1CurrentIndex == 0;
        }

        if (stack == 2) {
            return stack2CurrentIndex == arr.length - 1;
        }
    }
}

4.
a)
Step 1: Move car 4 from input track to holding track S1
Step 2: Move car 3 from input track to holding track S1
Step 3: Move car 1 from input track to output track
Step 4: Move car 8 from input track to holding track S2
Step 5: Move car 2 from input track to output track
Step 6: Move car 3 from holding track S1 to output track
Step 7: Move car 4 from holding track S1 to output track
Step 8: Move car 7 from input track to holding track S2
Step 9: Move car 6 from input track to holding track S2
Step 10: Move car 9 from input track to holding track S3
Step 11: Move car 5 from input track to output track
Step 12: Move car 6 from holding track S2 to output track
Step 13: Move car 7 from holding track S2 to output track
Step 14: Move car 8 from holding track S2 to output track
Step 15: Move car 8 from holding track S3 to output track

b) from the train front to back: 5, 9, 2, 7, 3, 4, 6, 8, 1
