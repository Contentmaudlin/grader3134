Andrew Lee, awl2144, Data Structures with Dr. Blaer Fall 2016

1.  public static void printLots(List<Integer> L, List<Integer> P){
    Iterator<Integer> iter = L.iterator();
    Iterator<Integer> iterP = P.iterator();

    int idxL = 0;
    int idxP = iterP.next(); //nth entry

    while (iterP.hasNext()) {
      if (idxP == idxL) {
        System.out.println(iter.next());
        idxL++;
        idxP = iterP.next();
      } else {
        idxL++;
        iter.next();
      }

    }
    while (iter.hasNext()) { //second loop needed to find the entry in L
      //which is at the last index specified in P
      if (idxP == idxL) {
        System.out.println(iter.next());
      } else {
        idxL++;
        iter.next();
      }

    }
  }



2.  public static List<Integer> intersect(List<Integer> l1, List<Integer> l2) {
    Iterator<Integer> l1Iter = l1.iterator();
    Iterator<Integer> l2Iter = l2.iterator();

    int l1Entry = l1Iter.next();
    int l2Entry = l2Iter.next();
    List<Integer> returnList = new ArrayList<Integer>();

    while (l1Iter.hasNext() || l2Iter.hasNext()) {
      if (l1Entry > l2Entry) {
        if (l2Iter.hasNext()) {
          l2Entry = l2Iter.next();
        }
      } else if (l2Entry > l1Entry) {
        if (l1Iter.hasNext()) {
          l1Entry = l1Iter.next();
        }
      } else {
        returnList.add(l1Entry);
        if (l1Iter.hasNext()) {
          l1Entry = l1Iter.next();
        }
        if (l2Iter.hasNext()) {
          l2Entry = l2Iter.next();
        }
      }
    }
    return returnList;
  }



3.


import java.util.NoSuchElementException;

public class TwoStacks {

  private int[] arr;
  int end1;
  int end2;

  public TwoStacks() {
    arr = new int[10];
    end2 = arr.length - 1;//end of second stack
    end1 = 0;//end of first stack
  }


  public TwoStacks(int length) {
    arr = new int[length];
    end2 = arr.length - 1;//end of second stack
    end1 = 0;//end of first stack
  }

  public void push1(int newEntry) {
    if (end1 >= end2 - 1) {
      throw new IllegalStateException("Both stacks are full");
    }
    arr[end1 + 1] = newEntry;
    end1++;
  }

  public void push2(int newEntry) {
    if (end1 >= end2 - 1) {
      throw new IllegalStateException("Both stacks are full");
    }
    arr[end2 - 1] = newEntry;
    end2--;
  }

  public int pop1() {
    if(end1 <= 0) {
      throw new IllegalStateException("Stack is empty");
    }
    int ret = arr[end1];
    end1--;
    return ret;
  }

  public int pop2() {
    if(end2 >= arr.length - 1) {
      throw new IllegalStateException("Stack is empty");
    }
    int ret = arr[end2];
    end2++;
    return ret;
  }

  public int peek1() {
    if(end1 <= 0) {
      throw new IllegalStateException("Stack is empty");
    }
    int ret = arr[end1];
    return ret;
  }

  public int peek2() {
    if(end1 >= arr.length - 1) {
      throw new IllegalStateException("Stack is empty");
    }
    int ret = arr[end2];
    return ret;
  }

  public boolean isEmpty1() {
    return (end1 == 0);
  }
  public boolean isEmpty2() {
    return (end2 == arr.length - 1);
  }


  public int size1() {
    return end1;
  }

  public int size2() {
    return arr.length - end2 - 1;
  }
}



4.a.

  Input track: 5,9,6,7,2,8,1,3,4

  1. Move 4 to Stack 1 followed by 3 to Stack 1
  Input track: 5,9,6,7,2,8,1
  Stack 1: 4,3
  Stack 2:
  Stack 3:
  Output track:

  2. Push 1 to the Output Track
  Input track: 5,9,6,7,2,8
  Stack 1: 4,3
  Stack 2:
  Stack 3:
  Output track: 1

  3. Move 8 to Stack 2
  Input track: 5,9,6,7,2
  Stack 1: 4,3
  Stack 2: 8
  Stack 3:
  Output track: 1

  4. Push 2 to the Output Track
  Input track: 5,9,6,7
  Stack 1: 4,3
  Stack 2: 8
  Stack 3:
  Output track: 1,2

  5. Move 7 to Stack 2 followed by 6 to Stack 2
  Input track: 5,9
  Stack 1: 4,3
  Stack 2: 8,7,6
  Stack 3:
  Output track: 1,2

  6. Move 9 to Stack 3 and then push 3 and then 4 from Stack 1 to the Output Track
  Input track: 5
  Stack 1:
  Stack 2: 8,7,6
  Stack 3: 9
  Output track: 1,2,3,4

  7. Push 5 to the Output Track then push 6 and then 7 and then 8 from Stack 2 to the Output Track
  Input track:
  Stack 1:
  Stack 2:
  Stack 3: 9
  Output track: 1,2,3,4,5,6,7,8

  8. Push 9 from Stack 3 to the Output Track
  Input track:
  Stack 1:
  Stack 2:
  Stack 3:
  Output track: 1,2,3,4,5,6,7,8,9

4.b.
  An example of a train that cannot be sorted has an input track: 1,5,7,4,3,2,9,8,6

  You cannot place a larger number on top of a smaller number in a holding track because
  that would mean that the larger number would have to come out before the smaller one
  underneath it. One cannot achieve an output track of 1,2,3,4,5,6,7,8,9 like this.

  So you must begin by placing 6, 8, and 9 each in their own holding track, as they leave
  the input track in increasing order. Next, you must do the same thing with 2, 3, and 4
  because they too leave the input track in increasing order. It does not matter which
  smaller number goes on top of which larger number because 6, 8, and 9 are all greater than
  2, 3, and 4. Also, none of these numbers can go to the output track because the output
  track only accepts 1 at first.

  The next number leaving the input track is 7, which you cannot place because you cannot
  place a larger number on top of a smaller number on a holding track and you cannot move it
  to the output track.



