Ziyi Sun
zs2293
COMS3134 

Hw2 Written

Problem 1

(Assumed list given was an ArrayList)

	private static <E> void printLots(List<E> LList, List<Integer> PList){
		List<E> L = LList;
		List<Integer> P = PList;
		
		Iterator<E> lIterator = L.iterator();
		Iterator<Integer> pIterator = P.iterator();
		
		
		//previous index's element in P
		int pPrev = 0;
		
		//if first element of p is 0
		boolean firstZero = false;
		
		while (pIterator.hasNext() && lIterator.hasNext()){
			
			//a is index of L to be printed
			//b is how many indexes to pass in L to get to next index			
			int a = pIterator.next();
			int b = a - pPrev;
			
			//elements in p must be > 0, no negative indices
			if (a < 0){
				throw new IndexOutOfBoundsException("negative element in p");
			}
			
			
			//if the p's first element is not zero
			//skip over one element in l
			if (a != 0 && firstZero == false){
				lIterator.next();
			}
			firstZero = true;

			//skip over b-1 indexes in  L and print the next index's element
			for (int i = 1; i < b; i++){
				if (lIterator.hasNext()){
					lIterator.next();}}
			if (lIterator.hasNext()){
				System.out.println(lIterator.next());}
				
			pPrev = a;	
			
			
			}		
			
		}

Problem 2

(Assumed list given in problem was an ArrayList)

	private static <AnyType> List<AnyType> 
		intersection(List<AnyType> a, List<AnyType> b){
		
		//find largest possible number of shared elements
		int size;
		if (a.size() > b.size()){
			size = b.size();
		}
		else{
			size = a.size();
		}
		
		//L3 is intersection of L1 and L2
		List<AnyType> intsxn = new ArrayList<AnyType>(size); 
		
		Iterator<AnyType> L1Iterator = a.iterator();
		Iterator<AnyType> L2Iterator = a.iterator();
		
		AnyType x = L1Iterator.next();
		AnyType y = L2Iterator.next();
		Boolean e = true;
		
		//iterate through both lists simultaneously
		while (e && (L1Iterator.hasNext() || L2Iterator.hasNext())){
			
			//if x = y, add to intersection, and increment one for both
			if (x == y){
				intsxn.add(x);
				if (L1Iterator.hasNext() && L2Iterator.hasNext()){
					x = L1Iterator.next();
					y = L2Iterator.next();
				}
				else{
					e = false;
				}
			}
			//if x < y, increment x
			else if (x<y && L1Iterator.hasNext()){
				x = L1Iterator.next();
			}
			//if x > y, increment y
			else if (x>y && L2Iterator.hasNext()){
				y = L2Iterator.next();
			}
			//stop iterating 
			else{
				e = false;
			}
		}
		
		return intsxn;
		
	}

Problem 3

(Using Array to implement 2 stacks)

import java.util.Arrays;

public class TwoStacks<E>{
	
	private E[] stack;
	private int top1;
	private int top2;
	private int size;
	
	//constructor initiates stack with set length
	//top1 and top2 are the indices of the top of the stacks
	public TwoStacks(int n){
		stack = (E[]) new Object[n];
		top1 = -1;	
		top2 = stack.length;
		size = stack.length;

	}
	
	//stack 1 expands from index 0 to end index
	//can push to stack 1 if top1 and top2 have an empty index in between 
	public void push1(E x){
		if (top1 < top2 + 1){
			top1++;
			stack[top1] = x;
		}
		else{
			System.out.println("Stack Overflow");
		}
		
	}
	
	public E pop1(){
		
		if (top1 > -1){
			E value = stack[top1];
			top1--;
			return value;
		}
		else{
			System.out.println("Stack 1 empty");
			return null;	
		}
	}
	
	public E peek1(){
		if (top1 > -1){
			return stack[top1];
		}
		else{
			System.out.println("Stack 1 empty");
			return null;
		}
		
	}
	
	//stack 2 expands from last index to index 0
	//can push to stack 1 if top1 and top2 have an empty index in between
	public void push2(E x){
		if (top2 > top1 + 1){
			top2--;
			stack[top2] = x;
		}
		else{
			System.out.println("Stack Underflow");
		}
	}
	
	public E pop2(){
		if (top2 < size){
			E value = stack[top2];
			top2++;
			return value;
		}
		else{
			System.out.println("Stack 2 empty");
			return null;
		}
	}
	
	public E peek2(){
		if (top2 < size){
			return stack[top2];
		}
		else{
			System.out.println("Stack 1 empty");
			return null;
		}
		
	}
	
	 public void display(){
	        System.out.println(Arrays.toString(stack));
	}
}


Problem 4
a.
1. Move 4 to S1
2. Move 3 to S1 on top of 4
3. Move 1 to back of output track
4. Move 8 to S2
5. Move 2 to back of output track
6. Move 3 to back of output track
7. Move 4 to back of output track
8. Move 7 to S2 on top of 8
9. Move 6 to S2 on top of 7
10. Move 9 to S3 
11. Move 5 to back of output track
12. Move 6 to back of output track
13. Move 7 to back of output track
14. Move 8 to back of output track
15. Move 9 to back of output track

b. 
[1,2,3,9,8,7,6,5,4] cannot be rearranged. 

In each of the three stacks, it must be ascending top down, meaning the last car to enter the stack is the smallest. [6,5,4] will have to be placed into three separate stacks, because you cannot place 5 in a stack above 4, or 6 above 5, or 6 above 4. [9,8,7] also have to be for the same reason. But none of [9,8,7] can be placed in a stack because they are all greater than [6,5,4]. 7 cannot be placed in as the first car in the output track either, or in any of the stacks. 7 cannot be placed anywhere for the desirable outcome, thus [1,2,3,9,8,7,6,5,4] cannot be rearranged. 