# Problem 1:

public static void printLots(List<Integer> L, List<Integer> P){

    Iterator<Integer> it_P = P.iterator();
    while (it_P.hasNext()) {
         int i = it_P.next();
         Iterator<Integer> it_L = L.iterator();
         for (int j = 0; j < i; j++){
            if (it_L.hasNext()){
               it_L.next();
            }
         }
         if (it_L.hasNext()){
             System.out.println(it_L.next());
        }
    }
}

# Problem 2: AND
function LIST_AND(List L1, List L2){
    Iterator it_L1 = L1.iterator()
    Iterator it_L2 = L2.iterator()
    List final = new List()
    a = it_L1.next()
    b = it_L2.next()
    while (it_L1.hasNext() and it_L2.hasNext()){
        if (a == b){
            final.add(a)
            a = it_L1.next()
            b = it_L2.next()
        }
        if (a < b){
            a = it_L1.next()
        }
        else {
            b = it_L2.next()
        }
    }

}

# Problem 3: TwoStackArray

class TSA<T>{


    int MAX_SIZE = N // some integer

    // stack_0 = forward stack: elements are inserted into increasing array indices
    // stack_1 = backward stack: elements are inserted into decreasing array indices

    int top[2]; // top[i] refers to the next available (empty) space in stack_i (0 or 1).
    int sz[2]; // sz[i] refers to the size of stack_i (0 or 1)
    int diff[2] = {-1, 1} // the differences to be added for array operation
    Array<T> a

    TSA(){
        a = new Array(MAX_SIZE)
        // set starting top location to the front and back of the array respectively
        top[0] = 0
        top[1] = MAX_SIZE-1

        // set size for both arrays to zero
        sz[0] = sz[1] = 0


    }

    // stack_push and stack_pop can be used for pushing and popping from either stack depending on the use input value
    // in the public push or pop method respectively. The appropriate top[i] marker variable is passed as a parameter
    // along with either +1 or -1 as the difference value to be added in order to advance to the next open spot
    // for push and pop.


    // private methods

    // forward stack (stack_0): diff = 1
    // backward stack (stack_1): diff = -1
    private void stack_push(T data, int top, int diff, int size){
        if (get_size() == MAX_SIZE){
            throw StackOverflowError
        }
        a[top] = data
        top = top + diff
        sz[stack_num]++

    }
    // forward stack (stack_0): diff = -1
    // backward stack (stack_1): diff = 1

    private T stack_pop(int top, int diff, int stack_num){
        if (top >= a.length-1 || top <= 0){
            throw NullPointerException
        }

        T elem = a[top + diff];
        top = top + diff
        sz[stack_num]--
        return elem
    }
    // makes sure that the user input is valid: either 0 for stack_0 or 1 for stack_1
    private boolean check_stack_number_valid(int num){
        if (num != 0 || num != 1){
            print "Input a valid stack number: 0 or 1"
            return false
        }

        return true
    }

    // public methods
    public void push(T data, int stack_num){
        if (!check_stack_number_valid(stack_num)){
            return null
        }
        // 1^stack_num = exclusive or on stack_num: 1^1 -> 0, 0^1 -> 1
        stack_push(data, top[stack_num], diff[1^stack_num], stack_num)

    }

    public T pop(int stack_num){
        if (!check_stack_number_valid(stack_num){
            return null
        }

        return stack_pop(s1_top[stack_num], diff[stack_num], stack_num);

    }

    public int get_size(){
        return sz[0] + sz[1]
    }

    public int get_size(int stack_num){
        if (!check_stack_number_valid(stack_num){
            return null
        }
        return sz[stack_num]
    }


}


# Problem 4:
a)
4 from In to S1
3 from In to S1
1 from In to Out
8 from In to S2
2 from In to Out
3 from S1 to Out
4 from S1 to Out
7 from In to S2
6 from In to S2
9 from In to S3
5 from In to Out
6 from S2 to Out
7 from S2 to Out
8 from S2 to Out
9 from S3 to Out

b)
1 9 8 7 6 5 4 3 2

