Problem 2:

Enqueue:

	//enqueue adds the element to the back
	//of the Queue(Top of S1)
	@Override
	public void enqueue(AnyType x) {
		S1.push(x);
	}

Since the push method has O(1) and this method just calls the push method, the efficiency of this method is O(1).

Dequeue:

	//dequeue method returns the element at
	//the front of the queue.
	//(pops elements from S1 and simultaneously
	//pushes them to top of S2, then pops S2)
	@Override
	public AnyType dequeue() {
		while(S1.size != 0) {
			S2.push(S1.pop());
		}
		if(S2.size == 0)
			return null;
		else
			return S2.pop();
	}

When S1 is full (reached memory limit)/Filled to a very high limit and we use the Dequeue method, itâ€™s an O(n) operation because of the while loop. But, apart from that, for instances in which there are fewer items in S1 and dequeue is performed, it will be an O(1) operation as the number of iterations of the while loop will also be less.