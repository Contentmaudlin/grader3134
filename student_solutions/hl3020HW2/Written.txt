Written Portion.
#1.

import java.util.*;

public class Problem1<AnyType>
{
	public static void printLots(List<Integer> a, List<Integer> b)
	{

		Iterator<Integer> itrA = a.iterator();
		Iterator<Integer> itrB = b.iterator();
		int x = 0; // this is the buffer to store i value used one prior to the iteration.
		int val = 0;

		for(int i : b)
		{
			int itr = i - x; // here I subtract i - x in order to get the difference between current index and the one before. 
			//System.out.println(i); //right now i = 1
			for(int j = 0; itrA.hasNext() && j < itr; j++) 
			{
				x = i; // x is 1 now. 
				val = itrA.next();
			}
			System.out.println(val);
		}
	}

#2. 

Method listIntersection(list A, list B)

List A = new List 
List B = new List
List C = new List
boolean redundant = false; // duplicate detection 

for(i : A)
{
	redundant = false; // reset to false. 
	 for(j : B)
	 {
	 	if(j == i)
	 	{
	 		if(!redundant)
	 		{
	 			C.push(j);
	 			redundant = true; // set redundant to true so that the same i is not pushed more than once. 
	 		}
	 	}
	 }
} 
// Iterate through list A using for-each. 
// Iterate through list B using for-each.
// if an item in list A equals an item in list B, push the item to list C and turn on the redundant.
// if another item in list B equals an item in list A, it will not be pushed due to redundancy.
// reset redundancy to false and repeat with the next item in list A. 

#3.

We will fill from the beginning and from the end. 

public class OneArrayTwoStack()
{

	AnyType[] twoStack = new AnyType[10] 	// let's say that the array is of length 10.
											// One stack starts at the beginning and fills to the right
	int indexA = 0;							// the second stack starts at the end and fills to the left.
	int indexB = 9;

	if(indexA < 0 || index B > 9)
	{
		System.out.println("Don't do that! Stack underflow!");
		throw EmptyStackException;
	}
	else if(indexA < indexB)
	{
		System.out.println("Overflow!");
		throw StackOverFlowError;
	}

	public void pushA(int x)
	{
		twoStack[indexA];
		indexA++;
	}
	public void pushB(int x)
	{
		twoStack[indexB];
		indexB--;

	}
	public AnyType popA()
	{
		value = twoStack[indexA];
		twoStack[indexA] = null;
		indexA--;

		return value;
	}
	public AnyType popB()
	{
		value = twoStack[indexB];
		twoStack[indexB] = null;
		indexB++;

		return value;
	}
}

#4.
let Shunting yards 1 2 and 3 be stack 1 2 and 3.

Put 4 into stack number 3.
put 3 into stack number 3.
Let 1 pass through.
put 8 into stack number 2. 
let 2 pass through.
Pop 3 from stack number 3.
Pop 4 from stack number 3.
Push 7 into stack number 2.
push 6 into stack number 2.
push 9 into stack number 3.
Let 5 pass through.
Pop 6 from stack number 2.
Pop 7 from stack number 2.
Pop 8 from stack number 2.
Pop 9 from stack number 9.

If there are three numbers between two numbers and those encapsulating two numbers are larger than the three numbers in between, and if the three numbers are not the next number, the sorting cannot work.

Example: 

546182379 will not work since 8 and 9 are larger than 2, 3 or 7 but 2, 3, 7 cannot be the first number in the sorted list (need = 1). The stacks will all be full and the sorting cannot be done. 



