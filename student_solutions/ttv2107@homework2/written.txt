Trung Vu
UNI: ttv2107
COMS W3134
Instructor: Professor Blaer
Homework 2
October 7th, 2016

Problem 1:

public static <T> void printLots(List<T> L, List<Integer> P) {
    Iterator<Integer> PIterator = P.iterator();
    Iterator<T> LIterator = L.iterator();    

    int i = 0; // This variable will keep track of the current position in L
    T curr = LIterator.next(); // This variable keeps track of the value
    // at the current position in L

    // Iterate over all elements in P using the iterator of P
    while (PIterator.hasNext()) {
        int pos = (PIterator.next()); // Retrieve the location we're looking for
        
        // Check to make sure that the location is not out of bounds
        if (pos >= L.size()) {
            System.out.println("Index out of bounds");
            return;
        }
        
        /* Retrieve the item in the location specified using 
         * the L iterator by travelling sequentially to that location.
         * Since P is sorted in ascending order, we only need to iterate
         * L once in order to retrieve the elements at the positions specified
         * in P. We only need to keep track of the position we're 
         * at and make sure we stop at the right position.
         */

        while (i < pos) {
            curr = LIterator.next();
            i++;
        }    
        System.out.println(curr);
    }
}

2. 

Assume that L1, L2 are sorted in increasing order, which means that
L1[i] <= L1[i+1] and L2[i] <= L2[i+1].

Assume that we are trying to find the set of intersection between L1 and L2, 
meaning that the intersection set contains no repeating elements.

Say the current position for L1 is i and current position for L2 is j.

(1) If (L1[i] = L2[j]), we add the element to the intersection (if the element
is not in the intersection set already), and move on to the next element in L1
and L2.

(2) If (L1[i] < L2[j]), then L1[i] must be smaller than elements in L2 after  
L2[j], since L2 is an increasing list. Furthermore, we also know that L1[i] is 
larger than all elements before L2[j] (if L1[i] was equal to an element before 
L2[j], it would have been iterated over, according to (1), and if L1[i] was
larger, it would have been iterated over, according to (3)). Therefore, L1[i]
is not in L2, and we move on to the next element in L1.

(3) If (L2[j] < L1[i]), then L2[j] must be smaller than elements in L1 after  
L1[i], since L1 is an increasing list. Furthermore, we also know that L2[j] is 
larger than all elements before L1[i] (if L2[j] was equal to an element before 
L1[i], it would have been iterated over, according to (1), and if L2[j] was
larger, it would have been iterated over, according to (2)). Therefore, L2[j]
is not in L1, and we move on to the next element in L2. 


We have the following algorithm:

    public static <T extends Comparable<T>> ArrayList<T> findIntersection(List<T> L1, List<T> L2) {
        ArrayList<T> intersection = new ArrayList<>();

        int k = -1; // This is the index of the last element 
                    // in the list of intersection
        
        // Initiate the iterators and the variables to keep track of
        // the current element for both arrays
        Iterator<T> L1iterator = L1.iterator();
        Iterator<T> L2iterator = L2.iterator();
        T currL1 = L1iterator.next();
        T currL2 = L2iterator.next();
 
        // Iterate over the two lists to find the intersection
        while (L1iterator.hasNext() && L2iterator.hasNext()) {
           if (currL1.compareTo(currL2) == 0) {
                // Check for repetition
                if ((k == -1) || (intersection.get(k) != currL1)) {
                    intersection.add(currL1);
                    k++;
                }
                currL1 = L1iterator.next();
                currL2 = L2iterator.next(); 
            } else if (currL1.compareTo(currL2) < 0) {
                currL1 = L1iterator.next();
            } else { 
                currL2 = L2iterator.next();
            }
        }

        return intersection;
    }
3. 
We can implement two stacks using one array if we imagine each end of the array
as the bottom of a stack.

One stack would be extending from the beginning of the array towards the end 
of the array, and the other would be extending from the end of the array
towards the beginning.

Then we can keep track of the position of the top of each stack in the array
using two index variables. We pop and push at these positions. These operations
would take O(1) time.

We throw overflow exception when the user tries to push an element into either
stack, but the top of the two stacks would be overlapping if we push a new 
element. In other words, the stacks overflow when the array is full.

We throw underflow exception when the user tries to pop an empty stack.

The code for the implementation is as follows:

public class TwoStackArray<T>{
    private int topStack1;
    private int topStack2;
    private T[] array;
    private static final int MAXIMUM_CAPACITY = 40;

    public TwoStackArray() {
        topStack1 = -1;
        topStack2 = MAXIMUM_CAPACITY;
        array = (T[]) new Object[MAXIMUM_CAPACITY];
    }

    public T popStack1() throws StackUnderflowException {
        if (topStack1 == -1) throw new StackUnderflowException();
        return array[topStack1--];
    }

    public void pushStack1(T x) throws StackOverflowException {
        if ((topStack1 + 1)  == topStack2) throw new StackOverflowException(); 
        array[++topStack1] = x;
    }

    public T popStack2() throws StackUnderflowException {
        if (topStack2 == MAXIMUM_CAPACITY) throw new StackUnderflowException();
        return array[topStack2++];
    }

    public void pushStack2(T x) throws StackOverflowException{
        if ((topStack2 - 1) == topStack1) throw new StackOverflowException();
        array[--topStack2] = x;
    }
    
    public int sizeStack1() {
        return (topStack1 + 1);
    }

    public int sizeStack2() {
        return (MAXIMUM_CAPACITY - topStack2);
    }

    public static class StackUnderflowException extends Exception {
        public StackUnderflowException() {};
        public StackUnderflowException(String message) {
            super(message);
        }
    }

    public static class StackOverflowException extends Exception {
        public StackOverflowException() {};
        public StackOverflowException(String message) {
            super(message);
        }
    }
}

4.
(a)
1. Push 4 into holding track 1
2. Push 3 into holding track 1
3. Enqueue 1 into output track
4. Push 8 into holding track 2
5. Enqueue 2 into output track
6. Pop 3 from holding track 1 and enqueue into output track
7. Pop 4 from holding track 1 and enqueue into output track
8. Push 7 into holding stack 2
9. Push 6 into holding stack 2
10. Push 9 into holding stack 1
11. Enqueue 5 into output track
12. Pop 6 from holding track 2 and enqueue into output track 
13. Pop 7 from holding track 2 and enqueue into output track 
14. Pop 8 from holding track 2 and enqueue into output track 
15. Pop 9 from holding track 1 and enqueue into output track 

(b) 8 - 7 - 6 - 2 - 9 - 5 - 4 - 3 - 1
