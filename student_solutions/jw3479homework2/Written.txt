Problem 1:
public static<Anytype> void printLots(List<Anytype> L, List<Integer> P){
	Iterator<Anytype> lIterator = L.iterator();
	int lSize = L.size();
	Anytype result = lIterator.next();
	int preIndex= 0;
	for (Integer pItem : P){
		if(pItem > lSize - 1){ // check index
			throw new IndexOutOfBoundsException();
		}
		for (int i = 0; i < pItem - preIndex; i++){
			result = lIterator.next();
		}
		preIndex = pItem;
		System.out.println(result);
	}
}


Problem 2:

public static List<Integer> compute(List<Integer> L1, List<Integer> L2){
	Iterator<Integer> Iterator1 = L1.iterator();
	Iterator<Integer> Iterator2 = L2.iterator();
	Integer temp = Iterator2.next(); // first element
	List<Integer> result = new ArrayList<>();
	for (Integer L1Item : L1){
		while (L1Item.compareTo(temp) > 0 && Iterator2.hasNext()){
			temp = Iterator2.next();
		}
		if(L1Item.compareTo(temp) > 0 && !Iterator2.hasNext()){
			return result;
		}
		if(L1Item == temp){
			result.add(L1Item);
			continue;
		}else {  // element in 2 bigger
			continue;
		}
	}
	return result;
}


Problem 3:


public class StackArray<AnyType> {
	private int top1Index;	// hold index for next element to be added
	private int top2Index;  //hold index for next element to be added
	private int size1;
	private int size2;
	private int size;
	private AnyType[] theArray;
	public StackArray(int s){		// capacity of array
		size = s;
		theArray = (AnyType[]) new Object[size];
		top1Index = 0;
		top2Index = size - 1;
		size1 = 0; 
		size2 = 0;
	}
	
	public void push1(AnyType x){
		if(top1Index == top2Index+1){
			throw new IndexOutOfBoundsException();
		}else{
			theArray[top1Index] = x;
			top1Index ++;
			size1 ++;
		}
	}
	
	public void push2(AnyType x){
		if(top2Index == top1Index-1){
			throw new IndexOutOfBoundsException();
		}else{
			theArray[top2Index] = x;
			top2Index --;
			size2 ++;
		}
	}
	
	public boolean isEmpty1(){
		return top1Index == 0;
	}
	
	public boolean isEmpty2(){
		return top2Index == size-1;
	}
	
	public AnyType top1(){
		if(isEmpty1()){
			return null;
		}else{
			return theArray[top1Index];
		}
	}
	
	public AnyType top2(){
		if(isEmpty2()){
			return null;
		}else{
			return theArray[top2Index];
		}
	}
	
	public AnyType pop1(){
		if(isEmpty1()){
			throw new java.util.NoSuchElementException();
		}else{
			AnyType result = theArray[top1Index-1];
			top1Index --;
			size1 --;
			return result;
		}
	}
	
	public AnyType pop2(){
		if(isEmpty2()){
			throw new java.util.NoSuchElementException();
		}else{
			AnyType result = theArray[top2Index+1];
			top2Index ++;
			size2 --;
			return result;
		}
	}
	
	public int size1(){
		return size1;
	}
	
	public int size2(){
		return size2;
	}
}


Problem 4:
a) 
push 4 from input to S1
push 3 from input to S1
push 1 from input to output
push 8 from input to S2
push 2 from input to output
pop 3 from S1 to output
pop 4 from S1 to output
push 7 from input to S2
push 6 from input to S2
push 9 from input to S1
push 5 from input to output
push 6 from S2 to output
push 7 from S2 to output
push 8 from S2 to output
push 9 from S1 to output

b)
Consider the original order as [1,2,3,4,5,9,8,7,6]
the ordering in the stack must be increasing from top to bottom
otherwise when poping to output cannot satisfy the ordering
for the front 4 cars, cannot go to output directly
must push 6 to holding (S1)
must push 7 to holding (S2), cannot go to S1 
must push 8 to holding (S3), cannot go to S1 or S2
must push 9 to holding, but cannot go to any of the holdings because
it is bigger than all the tops of the three stacks
Therefore this case cannot be solved