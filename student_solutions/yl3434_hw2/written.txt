
Name: Marie Lian
UNI: yl3434
Date: 10/10
Assignment: HW2

1. Note: Sorry I went ahead and wrote the actual compilable java code for this problem, I hope that is ok :)


public class Lots {
	public static void main(String[] args) {
		//main method for testing L and P and calling printLots
		List<Object> L = new ArrayList<Object>();
		List<Integer> P = new ArrayList<Integer>();
		
		// adds hard coded numbers into arrayLists
		L.addAll(Arrays.asList(4, 8, 15, 30, 67, 87));
		P.addAll(Arrays.asList(1, 3, 4, 6, 10));
		printLots(L, P);
	}
	public static void printLots(List<Object> L, List<Integer> P) {
		// P has integers sorted in ascending order
		// returns elements from L that are in position
		// of elements in P

		// make sure largest element in P is smaller than or equal to
		// length of L
		Iterator Lit = L.iterator();
		Iterator Pit = P.iterator();
		// create counter to keep track of index of L
		int counter = 0;
		//enhanced for loop for P
		for (int p : P) {
			// increment counter until it equals an int p
			// and L still hasNext
			while (counter<=p && Lit.hasNext()) {
				//next element of L
				Object element = Lit.next();
				// print out L elements when counter values equals
				// P value
				if (counter == p){
					System.out.println(element);
				}
				counter++;
			}
			//handles cases when int in P is larger than there are elements in L
			// or when there are no more elements in L to iterate through
			if (p > counter || Lit.hasNext() == false){
				System.out.println("Error, not enough elements in L for this P "
						+ "value");
			} 
		}
	}
}


2. /* Given two sorted lists, L1 and L2, write a procedure to compute L1 ∩ L2 using only
the basic list operations.*/

public class Intersection{
	
	public List intersection(list L1, list L2){
		list intersectList;
		int L1item = L1.head;
		int L2item = L2.head;
		//use compareTo()
		while( L1item != null && L2item != null )
		{
			int comparison = L1head.compareTo(L2head);
			if(comparison == 0)
				intersectList.add(L1item);
				L1item = L1item.next;
				L2item = L2item.next;
			else if(comparison > 0)
				L2item = L2item.next;
			else{
				L1item = L1item.next;
			}
		}
		return intersectList;
	}
}


3.
/*Write routines to implement two stacks using only one array. Your stack routines
	should not declare an overflow unless every slot in the array is used.
*/

public class twoStacks<AnyType> {
	// instance variable
	public int top1;
	public int top2;
	public AnyType[] array;
	public int size;

	// Constructor
	private void twoStacks(int n) {
		top1 = -1;
		top2 = n;
		AnyType[] array = new AnyType[n]; 
		size = n;
	}

	// push method for stack 1
	private void push1(AnyType i) {
		// when there is still space in the array to push to stack1
		if (top1 < top2 - 1) {
			array[++top1] = i;
		}
		// overflow declared since every spot is filled
		else {
			System.out.println("Overflow!");
			System.exit(0);
		}
	}

	// pop method for stack 1
	// returns -1 if underflowed
	private AnyType pop1() {
		//stack 1 is not empty
		if (top1 >= 0) {
			return array[top1--];
		} 
		//when stack 1 is empty
		else {
			System.out.println("Underflow!");
			return null;
		}
	}

	// Method to push an element x to stack2
	private void push2(AnyType i) {
		// when there is still space in the array to push to stack2
		if (top1 < top2 - 1) {
			array[--top2] = i;
		} 
		// overflow declared since every spot is filled
		else {
			System.out.println("Overflow!");
			System.exit(0);
		}
	}

	// Method to pop an element from second stack
	// returns -1 if underflowed
	private AnyType pop2() {
		if (top2 < size) {
			return array[top2++];
		} 
		else {
			System.out.println("Underflow!");
			return null;

		}
	}
	
	// isEmpty method for stack1
	private boolean isEmpty1()
    {
        if(top1 == 0)
            return true;
        else
            return false;
    }
	
	// isEmpty method for stack2
    private boolean isEmpty2()
    {
        if(top2 == size)
            return true;
        else
            return false;
    }
}
    

4. 
a) 
Move 4 so S1
Move 3 to S2
Move 1 to output
Move 8 to S3
Move 2 to output
Move 3 to output
Move 4 to output
Move 7 to S1
Move 6 to S1
Move 9 to S2
Move 5 to output
Move 6 to output
Move 7 to output
Move 8 to output
Move 9 to output

b) [298716345] is an example of a train of length 9 that cannot be rearranged in increasing order using 3 holding tracks









